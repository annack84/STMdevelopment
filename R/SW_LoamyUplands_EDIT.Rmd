---
title: 'Ecological Site Group Description: Semiarid Warm Loamy Uplands'
author: "Anna Knight, Travis Nauman, and Mike Duniway"
date: "05/02/2022"
output: 
  bookdown::html_document2:
    toc: true
    toc_depth: 1
    toc_float: true
    number_sections: false
---

<style type="text/css">

body{ /* Normal  */
      font-size: 14px;
  }
td {  /* Table  */
  font-size: 14px;
}
h1.title {
  font-size: 30px;
}
h1 { /* Header 1 */
  font-size: 26px;
}
h2 { /* Header 2 */
    font-size: 22px;
}
h3 { /* Header 3 */
  font-size: 18px;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>

*NOTE: This correspondence is intended for communication of project progress among funders and collaborators only. This information is preliminary and is subject to revision. It is being provided to meet the need for timely best science. The information is provided on the condition that neither the U.S. Geological Survey nor the U.S. Government shall be held liable for any damages resulting from the authorized or unauthorized use of the information.*

# General information
```{r setup, include=FALSE, error=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
target_ESG <- "Semiarid_Warm_LoamyUplands"
user <- "Anna"
#user <- "VPN"

library(dplyr)
library(kableExtra)
library(STMdevelopment)
```

```{r echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
# TODO insert dot graphic and text about the status of the ESD (e.g. "Provisional"). Might help
# to create a function to automatically insert the description based on the
# status input
```

```{r map, eval=TRUE, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE, fig.cap="Mapped extent", fig.width=5, fig.height=5}
EDIT_map(target_ESG = target_ESG, user = user, maxZoomStyle = "public")
```

Areas shown in blue indicate the maximum mapped extent of this ecological site. Other ecological sites likely occur within the highlighted areas. It is also possible for this ecological site to occur outside of highlighted areas if detailed soil survey has not been completed or recently updated.

## Associated ecological site concepts

This ecological site group includes a variety of upland ecological sites that have deeper sandy soils without significant rock content. The group was defined by placing ecological sites into groups by separating soils, climate, and geomorphic features to best differentiate reference vegetation production values and documented ecological states as documented by Nauman et al. (2022).

```{r echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
esds <- esd_data_pull(user=user, target_ESG = target_ESG)
comps <- comp_data_pull(user=user, target_ESG = target_ESG)
num_esds <- nrow(esds)
```

This ecological site group includes `r num_esds` ecological sites. These sites were correlated to the group based on average soil, climate and geomorphic properties of the soil components linked to each ecological site.

```{r assoc-eco-sites, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
## Associated ecological sites
format_tables_EDIT_style(data = esds[,c("ecoclassid","ecoclassname")],
                         col.names=c("ESD Code","ESD Name"),
                         caption = "Ecological Sites associated with this ESG",
                         row.names = F)
#knitr::kable(x = esds[,c("ecoclassid","ecoclassname")], col.names=c("ESD Code","ESD Name"), caption = NULL,row.names = F)
```

```{r dominant-plant-production, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
# TODO create table of dominant plant functional groups and species
esg_prod_list <- esg_production_pull(user=user, target_ESG = target_ESG)

dom_plants_df <- dplyr::tribble(~Item, ~Description,
                          "Trees", as.character(esg_prod_list[["Tree.df"]]$COMMON_NAME)[1:5],
                          "Shrubs", as.character(esg_prod_list[["Shrub.df"]]$COMMON_NAME)[1:5],
                          "Grasses",as.character(esg_prod_list[["Grass.df"]]$COMMON_NAME)[1:5],
                          "Forbs", as.character(esg_prod_list[["Forb.df"]]$COMMON_NAME)[1:5])

format_tables_EDIT_style(data = dom_plants_df,
                         caption = "Dominant plant species")
#knitr::kable(x = dom_plants_df, caption = "Table 1. Dominant plant species")
```


TODO insert "Download full description" link to a PDF


# Physiographic features

```{r get-landforms, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
# TODO create table of landforms, elevations, slopes, water table depth, flooding duration, flooding frequency, ponding frequency
# ideally should be able to tab between US and metric system measurements
landforms <- unlist(strsplit(esds$landfrms[1], split=","))
for(e in 2:nrow(esds)){
  esdlfs <- unlist(strsplit(esds[e,c("landfrms")],split=","))
  landforms <- append(landforms,esdlfs)
}
landforms <- landforms[!landforms %in% "NA"]
lfsum <-  factor(landforms)
lfsum <- reorder(lfsum,lfsum,FUN=function(x) -length(x))
landforms_unique <- unique(landforms)
```
These sites occur on upland positions with mostly gentle slopes on a variety of landforms (n=`r length(landforms_unique)`). Some areas can have steeper slopes, but these are not typical of the group. 

```{r physio-features, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}

# Slope
slope_ave <- mean(comps@site$slope_r.x)
slope_75th <- unname(quantile(comps@site$slope_r.x, probs = 0.75, na.rm = T))
slope_max <- max(comps@site$slope_r.x, na.rm = T)
slope_sd <- sd(comps@site$slope_r.x, na.rm = T)
slope_field <- paste("Slopes average",format(round(slope_ave, 1), nsmall = 1), 
                     "% with a standard deviation of",format(round(slope_sd, 1), nsmall = 1), 
                     "and are generally less than", format(round(slope_75th, 1), nsmall = 1),
                     "but can be up to", format(round(slope_max, 1), nsmall = 1),"%",sep=" ")

phys.df <- dplyr::tribble(~Item, ~Description,
                          "Landforms (Top 10)", as.character(unique(lfsum))[1:10],
                          "Slope", slope_field,
                          "Flooding Frequency","None",
                          "Aspect", "Aspect is not a significant factor")

format_tables_EDIT_style(data = phys.df, caption = "Representative physiographic features")
#knitr::kable(x = phys.df, caption = "Table 2. Representative physiographic features")
```

# Climatic features

Climate is generally semiarid and warm with aridity index (precipitation / potential evapotranspiration) values averaging `r format(round(mean(esds$aimean), 2), nsmall = 2)` and ranging from `r format(round(min(esds$aimean), 2), nsmall = 2)` to `r format(round(max(esds$aimean), 2), nsmall = 2)`. The average maximum temperatures (Celsius) of the hottest month range from `r format(round(min(esds$maxtempmean), 2), nsmall = 2)` to `r format(round(max(esds$maxtempmean), 2), nsmall = 2)`, and minimum temperatures of the coldest month range from `r format(round(min(esds$mintempmean), 2), nsmall = 2)` to `r format(round(max(esds$mintempmean), 2), nsmall = 2)`. Warm season (June to September) precipitation makes up `r format(round(mean(esds$pptrt*100), 0), nsmall = 0)`% of total precipitation on average, but can range from `r format(round(min(esds$pptrt*100), 0), nsmall = 0)`% to `r format(round(max(esds$pptrt*100), 0), nsmall = 0)`%.

```{r climate-features, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}

clim.df <- dplyr::tribble(~Item, ~Description,
                          "Frost Free Period (days)", paste(format(round(min(comps@site$ffd_r), 0), nsmall = 0),format(round(mean(comps@site$ffd_r), 0), nsmall = 0),format(round(max(comps@site$ffd_r), 0), nsmall = 0),sep=", "),
                          "Mean Annual Precipitation (in)", paste(format(round(min(comps@site$reannualprecip_r/25.4,na.rm=T), 1), nsmall = 1),format(round(mean(comps@site$reannualprecip_r/25.4,na.rm=T), 1), nsmall = 1),format(round(max(comps@site$reannualprecip_r/25.4,na.rm=T), 1), nsmall = 1),sep=", "))

format_tables_EDIT_style(data = clim.df, caption = "Representative climatic features (min, mean, max)")
#knitr::kable(x = clim.df, caption = "Table 3. Representative climatic features (min, mean, max)")
```

```{r echo=FALSE, error=FALSE, warning=FALSE, message=FALSE, fig.cap="Figure 1. Montly precipitation range"}
# TODO create line chart and bar charts of monthly high/low precip that you can tab between
```

```{r echo=FALSE, error=FALSE, warning=FALSE, message=FALSE, fig.cap="Figure 1. Montly average minimum and maximum temperature"}
# TODO create line chart and bar charts of monthly high/low temps that you can tab between
```

# Water features

These sites neither benefit significantly from run-in moisture nor experience excessive loss of moisture from runoff.

# Soil features

Soils in this group are moderately deep or deeper to bedrock and are composed primarily of alluvium and eolian sediments. Surface horizons have sand, loamy sand, sandy loam, and loam textures and subsurface horizons are similar but can also include sandy clay loams. Soils are non-saline and non sodic and can have up to 20% calcium carbonate, but generally have less than 6% carbonates. Soil pH ranges from 5.0 to 9.6, but is generally closer to 8.0. Water erosion hazard is moderate and wind erosion hazard is severe.  

```{r soil-features, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}

## Prep soil variables for table
surftext <-  factor(esds$txtnm_surf)
surftext <- reorder(surftext,surftext,FUN=function(x) -length(x))
surftext_uni <- levels(surftext)
subtext <-  factor(esds$txtnm_sub)
subtext <- reorder(subtext,subtext,FUN=function(x) -length(x))
subtext_uni <- levels(subtext)
drainage <- factor(comps@site$drainagecl.x)
drainage <- reorder(drainage,drainage,FUN=function(x) -length(x))
drainage_uni <- levels(drainage)[1:3]

## Make Table of soil descriptors: 
# TODO Could update pH to be based on esd averages instead of comps. Also could update PM to grab ssurgo values
soil.df <- dplyr::tribble(~Item, ~Description,
                          "Parent Material", "alluvium and eolian sediments",
                          "Surface Texture (0-30cm)", surftext_uni,
                          "Subsurface Texture (>30cm)",subtext_uni,
                          "Drainage", drainage_uni,
                          "Soil Depth", paste(format(round(min(esds$depthmean,na.rm=T), 0), nsmall = 0),"-",format(round(max(esds$depthmean,na.rm=T), 0), nsmall = 0), " cm",sep=""),
                          "Surface Rock Content %vol (0-30cm)", paste(format(round(min(esds$rock_surf,na.rm=T), 0), nsmall = 0),"-",format(round(max(esds$rock_surf,na.rm=T), 0), nsmall = 0), "%",sep=""),
                          "Subsurface Rock Content %vol (>30cm)", paste(format(round(min(esds$rock_sub,na.rm=T), 0), nsmall = 0),"-",format(round(max(esds$rock_sub,na.rm=T), 0), nsmall = 0), "%",sep=""),
                          "Surface Electrical Conductivity (0-30cm)", paste(format(round(min(esds$ec_surf,na.rm=T), 0), nsmall = 0),"-",format(round(max(esds$ec_surf,na.rm=T), 1), nsmall = 1), " dS/m",sep=""),
                          "Subsurface Electrical Conductivity (>30cm)", paste(format(round(min(esds$ec_sub,na.rm=T), 0), nsmall = 0),"-",format(round(max(esds$ec_sub,na.rm=T), 1), nsmall = 1), " dS/m",sep=""),
                          "Surface Sodium Adsorption Ratio (0-30cm)", paste(format(round(min(esds$sar_surf,na.rm=T), 0), nsmall = 0),"-",format(round(max(esds$sar_surf,na.rm=T), 1), nsmall = 1),sep=""),
                          "Subsurface Sodium Adsorption Ratio (>30cm)", paste(format(round(min(esds$sar_sub,na.rm=T), 0), nsmall = 0),"-",format(round(max(esds$sar_sub,na.rm=T), 1), nsmall = 1),sep=""),
                          "Surface 1:1 pH (0-30cm)", paste(format(round(min(comps@horizons[comps@horizons$hzdept_r<30,c("ph1to1h2o_r")],na.rm=T), 0), nsmall = 0),"-",format(round(max(comps@horizons[comps@horizons$hzdept_r<30,c("ph1to1h2o_r")],na.rm=T), 1), nsmall = 1),sep=""),
                          "Subsurface 1:1 pH (>30cm)", paste(format(round(min(comps@horizons[comps@horizons$hzdept_r>30,c("ph1to1h2o_r")],na.rm=T), 0), nsmall = 0),"-",format(round(max(comps@horizons[comps@horizons$hzdept_r>30,c("ph1to1h2o_r")],na.rm=T), 1), nsmall = 1),sep=""),
                          "Surface Calcium Carbonate (0-30cm)", paste(format(round(min(esds$caco3_surf,na.rm=T), 0), nsmall = 0),"-",format(round(max(esds$caco3_surf,na.rm=T), 0), nsmall = 0), "%",sep=""),
                          "Subsurface Calcium Carbonate (>30cm)", paste(format(round(min(esds$caco3_sub,na.rm=T), 0), nsmall = 0),"-",format(round(max(esds$caco3_sub,na.rm=T), 0), nsmall = 0), "%",sep=""))

format_tables_EDIT_style(data = soil.df, caption = "Representative soil features")
#knitr::kable(x = soil.df, caption = "Table 4. Representative soil features")
```

## Soil Component data

Soil types correlated to this group include `r length(unique(comps@site$cokey))` different components mapped in SSURGO. Soil taxonomic units include: 
```{r soil-tax-units, echo=FALSE, results = 'asis'}
cat(sort(unique(comps@site$compname)), sep = ", ")
``` 

### Component level soil property depth plots
```{r soil-lattice, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE, fig.cap="Soil properties by depth"}
agg <- aqp::slab(comps, fm= ~ claytotal_r + silttotal_r + sandtotal_r + ec_r + caco3_r)

lattice::xyplot(top ~ p.q50 | variable, data=agg, ylab='Depth (cm)',
             xlab='median bounded by 25th and 75th percentiles',
             lower=agg$p.q25, upper=agg$p.q75, ylim=c(201,-2),
             panel=aqp::panel.depth_function,
             alpha=0.25, sync.colors=TRUE,
             par.settings=list(superpose.line=list(col='RoyalBlue', lwd=2)),
             prepanel=aqp::prepanel.depth_function,
             cf=agg$contributing_fraction, cf.col='black', cf.interval=20, 
             layout=c(5,1), strip=lattice::strip.custom(bg=grey(0.8)),
             scales=list(x=list(tick.number=4, alternating=3, relation='free'))
             )

```

# Ecological dynamics

TODO narrative about key types of transitions and disturbances

## State and transition model development 

```{r apriori-stm, eval=TRUE, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
apriori_stms <- read.csv(data_file_paths(user)$apriori_stms, stringsAsFactors = F,
                         na.strings = c("NA", "", " "))

apriori_stms_target <- select(apriori_stms, any_of(c("State", "Plant_community", target_ESG)))
n_ESDs <- apriori_stms_target[apriori_stms_target$Plant_community=="n_ESDs", target_ESG]
colnames(apriori_stms_target) <- c("State", "Plant community", "Proportion of ESDs containing this plant community")

format_tables_EDIT_style(data = apriori_stms_target[-nrow(apriori_stms_target),],
                         caption = paste("State and plant community summary from Ecological Sites within this ESG.",
                                         n_ESDs, "complete STMs were available to include.")) %>%
  collapse_rows(columns = 1, valign = "top")
```

### Reference state production indicators
```{r ref-production, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE, fig.cap="Reference state production by plant functional group (based on reference states from Ecological Site Descriptions within this ESG)"}
## Plot of reference production indicators used in paper
resp_vars <- colnames(esds)[1:21]
resp_vars <- resp_vars[!resp_vars %in% c("ecoclassid","Ponderosa","Aspen")]
par(mar = c(4,8,4,2)) ## This works when knitted
boxplot(esds[,resp_vars], horizontal = TRUE,las = 1, main = "Reference Production (lbs/Acre)")

```

```{r load-plot-indicators, include=FALSE}
# by functional group cover
indicators <- c("AH_C3NativePerenGrassCover",
                "AH_C3IntroducedPerenGrassCover",
                "AH_C4NativePerenGrassCover",
                "AH_C4IntroducedPerenGrassCover",
                "AH_NativePerenForbCover", # Native perennial forbs
                "AH_IntroducedPerenForbCover", # Non-native perennial forbs
                "AH_NativeAnnGrassCover", # Native annual grasses
                "AH_IntroducedAnnGrassCover", # Non-native annual grasses
                "AH_NativeAnnForbCover", # Native annual forbs
                "AH_IntroducedAnnForbCover", # Non-native annual forbs
                "AH_ArtemisiaTridentataCover", # All big sagebrush species lumped together
                "BareSoilCover", # Bare soil
                "FH_TotalLitterCover", # Litter
                "CA_percent_100plus", # Canopy gaps > 100 cm
                "CA_percent_200plus",
                "FH_LichenCover", # Lichen + moss combined cover
                "FH_MossCover"#,
                #"SoilStab_all" # to represent cyano abundance... I think this is only marginally a community variable. If used in hierarchical clustering and Bray-Curtis NMDS, will need to standardize it to make units more similar to % cover units
                )

ann_grass_by_spp <- F
ann_forb_by_spp <- F
per_grass_by_spp <- F
per_forb_by_spp <- F
succulent_by_spp <- F
shrub_by_spp <- T # All shrubs and sub-shrubs by species
subshrub_by_spp <- T
tree_by_spp <- T # All trees by species
opuntia_combined <- T

data_sources <- c(#"BadgerWash",
                             #"CRCMonitoring", # drop if not needed for spatial representation
                             "IM_NCPN",
                             "LMF",
                             "NRI",
                             #"Parashant", # drop if not needed for spatial representation
                             "AIM"#, 
                             #"VanScoyocThesis" # drop if not needed for spatial representation
                           )

impute_gap_type <- c("CA_percent_100plus", "CA_percent_200plus")

plot_data <- plot_data_pull(user=user,
                             target_ESG = target_ESG,
                           data_sources = data_sources,
                           indicators = indicators,
                           ann_grass_by_spp = ann_grass_by_spp,
                           ann_forb_by_spp = ann_forb_by_spp,
                           per_grass_by_spp = per_grass_by_spp,
                           per_forb_by_spp = per_forb_by_spp,
                           succulent_by_spp = succulent_by_spp,
                           shrub_by_spp = shrub_by_spp,
                           subshrub_by_spp = subshrub_by_spp,
                           tree_by_spp = tree_by_spp,
                           opuntia_combined = opuntia_combined,
                           impute_gap_type = impute_gap_type
                           ) %>%
  filter(!is.na(Month))

```

```{r ordination-data, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
# TODO update I&M species codes to match current USDA Plants codes! probably a step for the plot_data_pull function?

# remove incomplete rows - ordination won't work with NAs
plot_data_clean <- na.omit(plot_data)

# Some plots were sampled multiple times - I'll include only the first year that a plot has complete data
plot_data_first <- plot_data_clean %>% #plot_data_clean %>%
  dplyr::group_by(PlotCode) %>%
  dplyr::arrange(.data=., Year, .by_group = TRUE) %>%
  dplyr::filter(dplyr::row_number()==1) %>%
  dplyr::ungroup()


# remove plots with SGU probability (i.e. certainty of prediction) in the 10th percentile
SGU_prob_raster <- raster::raster("C:/Users/aknight/Documents/Telework_Backups/V_drive/ANNA_KNIGHT/ESG/Maps/UCRB_SGUs_ProbMax/UCRB_SGUs_ProbMax.tif")

file_paths <- data_file_paths(user)
plot_locations <- sf::st_read(dsn = file.path(file_paths$plotnet_processed, "NRI/NRI_PlotNet"),
                              layer = "all_plot-years_2021-09-30",
                              quiet=TRUE)
if("NRI" %in% data_sources){
  nri_locations <- sf::st_read(dsn = file_paths$nri,
                               layer = "NRI_UCRB_plot-years_2021-11-01",
                               quiet = TRUE)
  
  plot_locations <- dplyr::filter(plot_locations, !grepl(pattern = "^NRI_",
                                                         x=PlotCode)) %>%
    dplyr::bind_rows(., nri_locations)
}

plot_SGU_prob <- sf::st_as_sf(raster::extract(x = SGU_prob_raster,
                               y = plot_locations,
                               sp = T))

plot_data_first <- left_join(plot_data_first, select(plot_SGU_prob, PlotCode, UCRB_SGUs_ProbMax)) %>%
  distinct() 

certainty_cutoff <- quantile(plot_data_first$UCRB_SGUs_ProbMax, probs = 0.1)

plot_data_first <- filter(plot_data_first, UCRB_SGUs_ProbMax > certainty_cutoff)

# make the clustering and ordination data frame - can't include ANY columns except the actual variables!
ord.df <- dplyr::select(plot_data_first, -SourceKey, -PlotID, -SiteName, -PlotName,
                        -Year, -Longitude_NAD83, -Latitude_NAD83,
                        -Month, -Day,
                        -UCRB_SGUs_ProbMax, -geometry
                        ) %>%
  tibble::column_to_rownames("PlotCode") # keep an ID code for the plot as the row name to prevent data scrambling problems

# If using soil stability, standardize variables to make units more similar
# Here, dividing by the max possible value for each measurement type (cover values
# divided by 100, soil stability divided by 6)
if("SoilStab_all" %in% indicators){
  ord.df.cover <- select(ord.df, -SoilStab_all)/100 
  ord.df.soilstab <- select(ord.df, SoilStab_all)/6
  ord.df <- cbind(ord.df.cover, ord.df.soilstab)
}

# remove rare species
sp_pa <- mutate(rowwise(ord.df), across(everything(), function(x){if(x>0){1}else{0}})) # make a presence/absence data frame
sp_keep <- names(colSums(sp_pa)[which(colSums(sp_pa)>2)]) 
ord.df <- select(ord.df, all_of(sp_keep))

# remove unknown species if present
ord.df <- select(ord.df, -any_of(c("UNKS", "UNKPG", "UNKAF", "UNKPF", "PG1", "PG01", "AF1")))
rm(plot_data_clean, plot_data)
```

Field data from were collected by field crews with the Natural Resource Conservation Service's (NRCS) National Resource Inventory (NRI) program, the Bureau of Land Management's (BLM) Assessment, Inventory, and Monitoring (AIM) and Landscape Monitoring Framework (LMF) programs, and the Nationa Park Service's (NPS) Inventory and Monitoring Northern Colorado Plateau Network (NCPN) program between `r min(plot_data_first$Year)` and `r max(plot_data_first$Year)`. Plots within the target ESG with SGU classification probability less than or equal to the 10th percentile were excluded, resulting in a total of `r nrow(ord.df)` plots for this ESG. Plant and soil cover were measured using line-point intercept and canopy gap methods (Herrick et al., 2017). Plot-level indicators (Table \@ref(tab:doc-plot-indicators)) were calculated using the terradactyl package in R (in development, McCord & Stauffer, 2020). When plots were sampled in multiple years, only the first sampling year was used in STM development. `r if(!is.null(impute_gap_type)){paste("For plots that were missing annual & perennial gap data but had perennial-only gap data (primarily I&M-NCPN), annual & perennial gap values were imputed from perennial-only gaps and annual herbaceous cover using a linear model built from LMF and NRI plots that had both types of gap (r-squared of 0.86 and 0.85 for 100-cm and 200-cm gap predictions, respectively).")}`

```{r doc-plot-indicators, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
indicator_descriptions <- make_indicator_descriptions(indicators = indicators,
                                                      shrub_by_spp = shrub_by_spp,
                                                      subshrub_by_spp = subshrub_by_spp,
                                                      tree_by_spp = tree_by_spp,
                                                      opuntia_combined = opuntia_combined)


format_tables_EDIT_style(data = indicator_descriptions[,-1],
                         caption = "Indicators used in ordination and clustering analysis to develop plant communities") %>%
  collapse_rows(columns = 1, valign = "top")
```

```{r hopkinsstat, eval=FALSE, echo=FALSE}
# are the data clusterable? Use the Hopkin's statistic (Lawson, Richard, and Jurs, 1990; see https://www.datanovia.com/en/lessons/assessing-clustering-tendency/ for explanation)
# H values > 0.5 indicate clustering tendency (i.e. if H is below 0.5, the data set is uniformly distributed and clusters are not meaningful)

res_LoamyUplands <- factoextra::get_clust_tendency(data = ord.df, n=nrow(ord.df)-1, graph = FALSE)
res_LoamyUplands$hopkins_stat
```

```{r clustering-setup, include=FALSE, message=FALSE, warning=FALSE}
# cluster and indicator species analysis
library(cluster) # for cluster analysis
library(dendextend)
library(labdsv)
library(foreach)
library(vegan)
library(ggplot2)

# initial clustering
dist.df <- vegan::vegdist(ord.df, method = "bray", na.rm = T) # creates Bray-Curtis distance matrix

```

```{r nbclust-fanny-loop, eval=FALSE, echo=FALSE, warning=FALSE}
# This chunk determines the best combination of number of clusters and fuzziness for the data. It is SLOOOOWWW so better to run it before knitting to get the right clustering parameters and then not run it when knitting the descriptive document.

# get index values for all combos of membership exponent and number of clusters

indices_arg <- c("ch", #"duda", won't work with the ranking scheme 
                 "cindex",
             #"gamma", # takes a long time
             #"beale", # unclear how this one works
             "ccc", "ptbiserial",
             #"gplus", # takes a long time
             "db", "silhouette", "dunn" #,
             #"gap" # takes a long time 
             ) 

indices_name <- c("CH", #"Duda",
                  "Cindex",
             #"gamma", # takes a long time
             #"Beale",
             "CCC", "Ptbiserial",
             #"gplus", # takes a long time
             "DB", "Silhouette", "Dunn" #,
             #"gap" # takes a long time 
             )

memb_exps <- seq(1.1,
                 1.3, # start with 2.0, can reduce value to rerun if some larger values don't give results
                 by = 0.1)

cl <- makeCluster(spec = 3, # number of cores to use
                  type = "PSOCK",
                  methods = FALSE)
registerDoParallel(cl)

cluster_eval_fanny <- foreach(memb_exp=memb_exps,
                              .packages = c("STMdevelopment", "dplyr", "cluster"),
                              .combine = "rbind") %dopar% {
      nbmetrics_fanny_temp <- NbClust_fanny(data = ord.df,
              diss = dist.df, #chord.df,
              distance = NULL,
              min.nc = 2,
              max.nc = 12,
              method = "fanny",
              index = "all", # could also try alllong to get a few more metrics - this is SLOW
              alphaBeale = 0.1,
              memb.exp= memb_exp # 1.2
              )
    
    cluster_eval_fanny_temp <- nbmetrics_fanny_temp$All.index %>%
      as.data.frame() %>%
      mutate(Number_clusters = rownames(.),
             Memb_exp = memb_exp)
}

registerDoSEQ()
stopCluster(cl)

cluster_eval_fanny_indices <- select(cluster_eval_fanny, any_of(c("Memb_exp", "Number_clusters", indices_name)))

# calculate percent worst than best value for each memb. exp. X num. clusters combo for each index

pct_off_best_higher <- function(x, all_vals){
  best <- max(all_vals)
  pct_off <- ((best-x)/best)*100
  return(pct_off)
}

pct_off_best_lower <- function(x, all_vals){ 
  best <- min(all_vals)
  pct_off <- ((x-best)/best)*100
  return(pct_off)
}

cluster_eval_fanny_indices_rank <- cluster_eval_fanny_indices %>%
  rowwise() %>%
  mutate(CH_rank = pct_off_best_higher(CH, cluster_eval_fanny_indices$CH),
         Cindex_rank = pct_off_best_lower(Cindex, cluster_eval_fanny_indices$Cindex),
         CCC_rank = pct_off_best_higher(CCC, cluster_eval_fanny_indices$CCC),
         Ptbiserial_rank = pct_off_best_higher(Ptbiserial, cluster_eval_fanny_indices$Ptbiserial),
         DB_rank = pct_off_best_lower(DB, cluster_eval_fanny_indices$DB),
         Silhouette_rank = pct_off_best_higher(Silhouette, cluster_eval_fanny_indices$Silhouette),
         Dunn_rank = pct_off_best_higher(Dunn, cluster_eval_fanny_indices$Dunn)
         ) %>%
  mutate(overall_rank = sum(CH_rank, # lowest overall rank wins!
                            Cindex_rank,
                            CCC_rank,
                            Ptbiserial_rank,
                            DB_rank,
                            Silhouette_rank,
                            Dunn_rank,
                            na.rm = T))

best_n_clust <- as.numeric(cluster_eval_fanny_indices_rank[[which.min(cluster_eval_fanny_indices_rank$overall_rank), "Number_clusters"]])
best_memb_exp <- as.numeric(cluster_eval_fanny_indices_rank[[which.min(cluster_eval_fanny_indices_rank$overall_rank), "Memb_exp"]])

# VISUALLY CHECK for ties and ranking weirdness before proceeding!!
```


```{r fuzzy-cluster, echo=FALSE}
k_groups_fuzzy <- 5 
memb_exp <- 1.1

set.seed(1)
clust_fuzz <- fanny(x=dist.df,
                    k = k_groups_fuzzy, # 2
                    diss = T,
                    #metric = "euclidean",
                    memb.exp = # this affects how crisp/fuzzy the clusters are - closer to 1 is crisper
                      memb_exp # 1.1
                    )


grp_fuzz <- clust_fuzz$clustering
plot_data_first$PlantCommunity_fuzzy <- as.factor(grp_fuzz)

```

Plots were clustered into ecological communities using the FANNY fuzzy clustering algorithm (Kaufman and Rousseeuw, 1990) in the "cluster" R package (Maechler et al., 2021) with Bray-Curtis distance ("vegan" package; Oksanen et al., 2020). A suite of clustering indices were used to determine the most appropriate number of clusters and degree of fuzziness (i.e. membership exponent), including Calinski and Harabasz (1974), C-index (Hubert and Levin, 1976), cubic clustering criteria (Sarle, 1983), point-biserial correlation (Milligan 1980, 1981), Davies and Bouldin (1979), silhouette width (Rousseeuw 1987), and Dunn's index (1974). Values between 1 and 12 possible clusters and 1.1 to 1.3 membership exponents were tested. The final clustering solution used `r k_groups_fuzzy` clusters with a membership exponent of `r memb_exp`. 

```{r ordination-scree, eval=FALSE, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE, results='hide', fig.keep='all', cache=FALSE, fig.cap="NMDS ordination scree plot comparing number of dimensions in the solution to stress."}
# another slow chunk - run before knitting and then don't evaluate in the knit step.
NMDS_scree(ord.df)
```

```{r ordination, eval=TRUE, include=FALSE}
ord_dims <- 3 # change manually based on the plot results

#run NMS ordination 
set.seed(1)
ord <- metaMDS(ord.df,
               k=ord_dims, # number of dimensions
               trymax = 30) 

```

The clustering results were visualized in ordination spaced, using non-metric multidimensional scaling (NMDS) with Bray-Curtis distance ("vegan" package in R). Based on testing ordination stress for 1 to 5 dimensions, ordination stress is acceptable with `r ord_dims` dimensions, and stress reduction is minimal with additional dimensions. The stress for the ordination with `r ord_dims` dimensions is `r round(ord$stress, 3)`.

```{r ordination-plots, echo=FALSE, fig.height=10, fig.width=10, fig.cap="NMDS ordination of plot indicator data. Points represent plots; ellipses represent plant communities identified by the hierarchical clustering and indicator species analysis."}
# 2D plotting
pal_veg2 <- RColorBrewer::brewer.pal(n=k_groups_fuzzy, name = "Dark2")
# manually update based on indicator species
group_labels_fuzzy <- c(paste0("C4 & C3 perennial
grassland (n = ", nrow(filter(plot_data_first, PlantCommunity_fuzzy==1)), ")"),
                        paste0("Depauperate grassland
(n = ", nrow(filter(plot_data_first, PlantCommunity_fuzzy==2)), ")"),
                        paste0("Sagebrush & C3 perennial
grass shrubland (n = ", nrow(filter(plot_data_first, PlantCommunity_fuzzy==3)), ")"),
                        paste0("Gambel oak
shrubland (n = ", nrow(filter(plot_data_first, PlantCommunity_fuzzy==4)), ")"),
                        paste0("Non-native annual
grassland (n = ", nrow(filter(plot_data_first, PlantCommunity_fuzzy==5)), ")"))

#group_labels <- as.character(1:clust_fuzz$k.crisp)

par(mfrow=c(2,2))
# Axes 1x2
plot(ord, choices = c(1,2), type = "n", # plot the axes
     xlim = c(-1, 1),
     ylim = c(-1, 1))
points(ord, choices = c(1,2), display = "sites", # plot points - can choose "sites" or "species"
       col=pal_veg2[plot_data_first$PlantCommunity_fuzzy],
       pch = 21, cex = .6, bg=pal_veg2[plot_data_first$PlantCommunity_fuzzy])
ordiellipse(ord, plot_data_first$PlantCommunity_fuzzy, col=pal_veg2, lwd = 2, label = F,
            choices = c(1,2)) # plot your groups
# can use oriellipse, orihull, or ordispider to plot groups, depending on your needs

# Axes 3x2
plot(ord, choices = c(3,2), type = "n", 
     xlim = c(-1, 1),
     ylim = c(-1, 1))
points(ord, choices = c(3,2), display = "sites", 
       col=pal_veg2[plot_data_first$PlantCommunity_fuzzy],
       pch = 21, cex = .6, bg=pal_veg2[plot_data_first$PlantCommunity_fuzzy])
ordiellipse(ord, plot_data_first$PlantCommunity_fuzzy, col=pal_veg2, lwd = 2, label = F,
            choices = c(3,2)) 

# Axes 1x3
plot(ord, choices = c(1,3), type = "n",
     xlim = c(-1, 1),
     ylim = c(-1, 1))
points(ord, choices = c(1,3), display = "sites",
       col=pal_veg2[plot_data_first$PlantCommunity_fuzzy],
       pch = 21, cex = .6, bg=pal_veg2[plot_data_first$PlantCommunity_fuzzy])
ordiellipse(ord, plot_data_first$PlantCommunity_fuzzy, col=pal_veg2, lwd = 2, label = F,
            choices = c(1,3)) 

# Legend
plot(ord, type = "n", axes=FALSE,
     display = "sites",
     col=pal_veg2[plot_data_first$PlantCommunity_fuzzy],
     xlab = "",
     ylab = "")
legend(x="center",
       legend = group_labels_fuzzy,
       fill = pal_veg2,
       title = "Plant communities",
       bty = "n",
       y.intersp = 1.5)

par(mfrow=c(1,1))

```

```{r save-fuzzy-cluster, echo=FALSE, eval=FALSE}
# save clustering results
fuzzy_cluster_membership <- as.data.frame(clust_fuzz$membership)
fuzzy_cluster_membership$PlotCode <- row.names(clust_fuzz$membership)
fuzzy_cluster_membership$best_group <- clust_fuzz$clustering

colnames(fuzzy_cluster_membership) <- c(paste0("Group_", 1:5, "_membership"), "PlotCode", "Best_group")

group_names <- data.frame(Best_group = 1:5,
                          Best_group_name = c("C4 & C3 perennial grassland",
                                         "Depauperate grassland",                   
                                         "Sagebrush & C3 perennial grass shrubland",
                                         "Gambel oak shrubland",                     
                                         "Non-native annual grassland"))
fuzzy_cluster_membership <- left_join(fuzzy_cluster_membership, group_names)

# get the plot location and date sampled (use first date)
plot_locations_first <- plot_locations %>%
  mutate(DateSampled = as.Date(paste(Year, Month, Day, sep = "-"))) %>%
  arrange(DateSampled) %>%
  group_by(PlotCode) %>%
  summarise(DateSampled = first(DateSampled))

fuzzy_cluster_memb_sf <- left_join(fuzzy_cluster_membership, plot_locations_first)

sf::st_write(fuzzy_cluster_memb_sf,
             dsn = "C:/Users/aknight/Documents/Telework_Backups/V_drive/ANNA_KNIGHT/ESG/Maps",
             layer = paste0("SW_LoamyUplands_fuzzyclusters_", Sys.Date(), ".shp"),
             driver = "ESRI Shapefile")

fuzzy_cluster_memb_sf_shareable <- filter(fuzzy_cluster_memb_sf, !grepl(pattern = "NRI", x=PlotCode))

sf::st_write(fuzzy_cluster_memb_sf_shareable,
             dsn = "C:/Users/aknight/Documents/Telework_Backups/V_drive/ANNA_KNIGHT/ESG/Maps",
             layer = paste0("SW_LoamyUplands_fuzzyclust_share_", Sys.Date(), ".shp"),
             driver = "ESRI Shapefile")

```

## State and transition model {.tabset}

### CUSTOM DIAGRAM

```{r custom-stm, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE, fig.cap="STM", fig.height=8, fig.width=10}
# TODO create custom diagram of states
knitr::include_graphics("C:/Users/aknight/Documents/Telework_Backups/V_drive/ANNA_KNIGHT/ESG/STM/Analyses/Semiarid_Warm_LoamyUplands_boxandarrow_DRAFT.JPG")
```

```{r echo=FALSE, error=FALSE, warning=FALSE, message=FALSE, fig.cap="Legend"}
# TODO legend for custom diagram if needed
```

The data used to develop this STM were sourced from large monitoring data sets designed to sample landscapes with a variety of current and historic land use. The model does not describe reference communities because these data do not include targeted sampling of relict plant communities with histories of little alteration to disturbance regimes. All states described here contain some introduced species (e.g. *Bromus tectorum, Alyssum desertorum, Agropyron cristatum*; see Tables \@ref(tab:comm1-1-dominant-spp), \@ref(tab:comm2-1-dominant-spp), \@ref(tab:comm3-1-dominant-spp), \@ref(tab:comm4-1-dominant-spp), and \@ref(tab:comm5-1-dominant-spp) for details).

For furthur information on reference states as well as drivers of transitions, see the Ecological Site Descriptions for the sites listed in Table \@ref(tab:assoc-eco-sites).

### STANDARD DIAGRAM

Click on state and transition labels to scroll to the respective text.

TODO create boxes for each state that link to the state description below

## State descriptive figures

```{r load-descriptive-indicators, include=FALSE}
# load descriptive data
plot_data_descriptive <- plot_data_pull(user=user,
                                        target_ESG = target_ESG,
                                        data_sources = data_sources,
                                        indicators = c("TotalFoliarCover",
                                                       "AH_WoodyCover",
                                                       "AH_ShrubCover",
                                                       # TODO what to do about subshrubs??
                                                       "AH_TreeCover",
                                                       "AH_ForbGrassCover",
                                                       "AH_PerenForbGrassCover",
                                                       "AH_AnnForbGrassCover",
                                                       "SoilStab_all",
                                                       "AH_ArtemisiaTridentataCover"),
                                        ann_grass_by_spp = T,
                                        ann_forb_by_spp = T,
                                        per_grass_by_spp = T,
                                        per_forb_by_spp = T,
                                        succulent_by_spp = T,
                                        shrub_by_spp = T,
                                        subshrub_by_spp = T,
                                        tree_by_spp = T,
                                        opuntia_combined = F
) %>%
  filter(!is.na(Month)) %>%
  left_join(select(plot_data_first, PlotCode, Year, PlantCommunity_fuzzy) , .)

colnames(plot_data_descriptive)[which(colnames(plot_data_descriptive)=="AH_ArtemisiaTridentataCover")] <- "ARTR2"

# summarize species occurrance
descriptive.df <- dplyr::select(plot_data_descriptive, -SourceKey, -PlotID, -SiteName, -PlotName,
                        -Year, -Longitude_NAD83, -Latitude_NAD83,
                        -Month, -Day, -PlantCommunity_fuzzy, -TotalFoliarCover,
                        -AH_WoodyCover, -AH_ShrubCover, -AH_TreeCover, -AH_ForbGrassCover, 
                        -AH_PerenForbGrassCover, -AH_AnnForbGrassCover,
                        -SoilStab_all
                        ) %>%
  tibble::column_to_rownames("PlotCode") # keep an ID code for the plot as the row name to prevent data scrambling problems

sp_pa_desc <- mutate(rowwise(descriptive.df), across(everything(), function(x){if(x>0){1}else{0}})) # make a presence/absence data frame
sp_keep_desc <- names(colSums(sp_pa_desc)[which(colSums(sp_pa_desc)>0)]) 
descriptive.df <- select(descriptive.df, all_of(sp_keep_desc))

plot_data_descriptive <- select(plot_data_descriptive, SourceKey, PlotID, SiteName, PlotName,
                        Year, PlotCode, Longitude_NAD83, Latitude_NAD83,
                        Month, Day, PlantCommunity_fuzzy, TotalFoliarCover,
                        AH_WoodyCover, AH_ShrubCover, AH_TreeCover, AH_ForbGrassCover, 
                        AH_PerenForbGrassCover, AH_AnnForbGrassCover,
                        SoilStab_all, all_of(sp_keep_desc))

#ord.df <- select(ord.df, -any_of(c("UNKS", "UNKPG", "UNKAF", "UNKPF", "PG1", "PG01", "AF1")))

## load climate data
AI_raster <- raster::raster(file_paths$ai_raster)
plot_AI <- sf::st_as_sf(raster::extract(x = AI_raster,
                               y = plot_locations,
                               sp = T)) %>%
  mutate(AI = ai_et0_WesternUSEcoregions*0.0001 # AI rasters are actually AI*10,000 so that they
                  #can be stored as integers - need to put back into standard AI units
                  ) %>%
  sf::st_drop_geometry()
rm(AI_raster)

climate_rasters <- raster::stack(file_paths$prism_rasters)
prism_vals <- raster::extract(x=climate_rasters,
                              y=plot_locations,
                              sp = T) %>%
  as(., "sf")
sf::st_geometry(prism_vals) <- NULL
colnames(prism_vals)[which(colnames(prism_vals) %in% c("PRISM_ppt_30yr_normal_800mM2_annual_asc",
                                                       "PRISM_tmean_30yr_normal_800mM2_annual_asc",
                                                       "PRISM_tmax_30yr_normal_800mM2_annual_asc",
                                                       "PRISM_tmin_30yr_normal_800mM2_annual_asc"
                                                       ))] <- c("Ann_ppt_mm", "Ann_tmean",
                                                                "Ann_tmax", "Ann_tmin")
rm(climate_rasters)

plot_data_descriptive <- left_join(plot_data_descriptive,
                               select(plot_AI, PlotCode, Year, AI)) %>%
  left_join(., 
            select(prism_vals, PlotCode, Year, Ann_ppt_mm, Ann_tmean, Ann_tmax, Ann_tmin))

## species richness and diversity
plot_data_descriptive$shannon_diversity <- vegan::diversity(x=descriptive.df, index = "shannon")
plot_data_descriptive$sp_richness <- vegan::specnumber(x=descriptive.df)

# other variables to assess:
# RHEM
# AERO
# elevation
# soil pit variables??
```

```{r plant-groups, echo=FALSE, message=FALSE, warning=FALSE, fig.height=20, fig.width=12, fig.cap="Plant cover by community"}
## consider including species present in >10% of plots:
#names(colSums(sp_pa)[which(colSums(sp_pa)>(nrow(plot_data_first)*0.10))])
## also consider including species with high mean cover across all plots:
#mean_cover <- summarise(plot_data_first, across(.cols = AH_C3IntroducedPerenGrassCover:AH_OpuntiaCover, .fns = mean)) %>%
#  select(-any_of(c("Longitude_NAD83", "Latitude_NAD83", "Year", "Month", "Day"))) %>%
#  t() %>%
#  as.data.frame()

#row.names(mean_cover)[which(mean_cover$V1>=0.9)]

plot_data_first_tall <- select(plot_data_first,
                                             SourceKey, PlotID, SiteName,
                                             PlotName, Year, PlotCode,
                                             #PlantCommunity,
                                             PlantCommunity_fuzzy,
                                             AH_C3IntroducedPerenGrassCover, 
                                             AH_C3NativePerenGrassCover,     
                                             AH_C4NativePerenGrassCover,
                                             AH_IntroducedAnnForbCover,
                                             AH_IntroducedAnnGrassCover,
                                             AH_IntroducedPerenForbCover,    
                                             AH_NativeAnnForbCover, 
                                             AH_NativeAnnGrassCover,
                                             AH_NativePerenForbCover, 
                                             BareSoilCover,                  
                                             FH_TotalLitterCover, 
                                             AH_ArtemisiaTridentataCover,
                                             CA_percent_200plus, 
                                             AH_C4IntroducedPerenGrassCover, 
                                             FH_LichenMossCover,
                                             CA_percent_100plus, 
                                             CHVI8,
                               SYRO,
                               #ERNA10,
                               #SAVE4,
                               #PUTR2,
                               #GUSA2,
                               PIED,
                               JUOS,
                               QUGA#,
                               #AMUT,
                               #AMAL2
                               ) %>%
  tidyr::pivot_longer(cols = c(AH_C3IntroducedPerenGrassCover, 
                                             AH_C3NativePerenGrassCover,     
                                             AH_C4NativePerenGrassCover,
                                             AH_IntroducedAnnForbCover,
                                             AH_IntroducedAnnGrassCover,
                                             AH_IntroducedPerenForbCover,    
                                             AH_NativeAnnForbCover, 
                                             AH_NativeAnnGrassCover,
                                             AH_NativePerenForbCover, 
                                             BareSoilCover,                  
                                             FH_TotalLitterCover, 
                                             AH_ArtemisiaTridentataCover,
                                             CA_percent_200plus, 
                                             AH_C4IntroducedPerenGrassCover, 
                                             FH_LichenMossCover,
                                             CA_percent_100plus, 
                                             CHVI8,
                               SYRO,
                               #ERNA10,
                               #SAVE4,
                               #PUTR2,
                               #GUSA2,
                               PIED,
                               JUOS,
                               QUGA#,
                               #AMUT,
                               #AMAL2
                               ),
                      names_to = "CoverType",
                      values_to = "PctCover")


spp_list <- read.csv(file_paths$species_list)

cover_funcgrps <- sort(c("AH_C3IntroducedPerenGrassCover", 
                 "AH_C3NativePerenGrassCover",     
                 "AH_C4NativePerenGrassCover",
                 "AH_IntroducedAnnForbCover",
                 "AH_IntroducedAnnGrassCover",
                 "AH_IntroducedPerenForbCover",    
                 "AH_NativeAnnForbCover", 
                 "AH_NativeAnnGrassCover",
                 "AH_NativePerenForbCover", 
                 "BareSoilCover",                  
                 "FH_TotalLitterCover", 
                 "AH_ArtemisiaTridentataCover",
                 "CA_percent_200plus", 
                 "AH_C4IntroducedPerenGrassCover", 
                 "FH_LichenMossCover",
                 "CA_percent_100plus"))
funcgrps_names <- arrange(filter(indicator_descriptions, Indicator_code %in% cover_funcgrps), Indicator_code)$Indicator
names(cover_funcgrps) <- funcgrps_names

cover_spp <- sort(c("CHVI8",
                    "SYRO",
                    #"ERNA10",
                    #"SAVE4",
                    #"PUTR2",
                    #"GUSA2",
                    "PIED",
                    "JUOS",
                    "QUGA"#,
                    #"AMUT",
                    #"AMAL2"
                    ))
spp_names <- paste0( filter(spp_list, SpeciesCode %in% cover_spp & SpeciesState=="AIM")$ScientificName,
                    " (", filter(spp_list, SpeciesCode %in% cover_spp & SpeciesState=="AIM")$CommonName, ")")
names(cover_spp) <- spp_names

cover_labels <- sort(c(cover_funcgrps, cover_spp))

functypes_grps <- c("TotalFoliarCover", #"AH_WoodyCover", #AH_ForbGrassCover, 
                    "AH_ShrubCover", "AH_TreeCover",
                        "AH_PerenForbGrassCover", "AH_AnnForbGrassCover"
                )
functypes_cover_states <- ggplot(data = select(plot_data_descriptive, 
                                             any_of(c("PlantCommunity_fuzzy", functypes_grps))) %>%
                                   tidyr::pivot_longer(cols = all_of(functypes_grps),
                      names_to = "CoverType",
                      values_to = "PctCover"),
                             aes(x=PlantCommunity_fuzzy, y=PctCover, fill=CoverType)) +
  geom_boxplot() +
  scale_fill_brewer(type = "qual", palette = "Set3",
                    name = "Functional type",
                    labels = c("Annual herbaceous", "Perennial herbaceous",
                               #"Woody",
                               "Shrub", "Tree",
                               "Total foliar cover")
                    ) +
  scale_x_discrete(labels=group_labels_fuzzy) +
  xlab(NULL) +
  ylab("Cover (%)") +
  ggtitle("Plant functional groups") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"),
        axis.text.y = element_text(color = "black"))

woody_grps <- c("AH_ArtemisiaTridentataCover", "CHVI8", "SYRO",
                #"ERNA10", "SAVE4", "PUTR2", "GUSA2",
                "PIED", "JUOS", "QUGA"#,
                #"AMUT", "AMAL2"
                )
woody_cover_states <- ggplot(data = filter(plot_data_first_tall, CoverType %in% woody_grps),
                             aes(x=PlantCommunity_fuzzy, y=PctCover, fill=CoverType)) +
  geom_boxplot() +
  scale_fill_brewer(type = "qual", palette = "Set3",
                    name = "Species",
                    labels = names(cover_labels[which(cover_labels %in% woody_grps)])) +
  scale_x_discrete(labels=group_labels_fuzzy) +
  xlab(NULL) +
  ylab("Cover (%)") +
  ggtitle("Woody plants") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"),
        axis.text.y = element_text(color = "black"))

perenherb_grps <- c("AH_C3IntroducedPerenGrassCover", "AH_C3NativePerenGrassCover", 
                    "AH_C4IntroducedPerenGrassCover", "AH_C4NativePerenGrassCover",
                    "AH_IntroducedPerenForbCover", "AH_NativePerenForbCover")
perenherb_cover_states <- ggplot(data = filter(plot_data_first_tall, CoverType %in% perenherb_grps),
                                 aes(x=PlantCommunity_fuzzy, y=PctCover, fill=CoverType)) +
  geom_boxplot() +
  scale_fill_brewer(type = "qual", palette = "Set3",
                    name = "Functional group",
                    labels = names(cover_labels[which(cover_labels %in% perenherb_grps)])) +
  scale_x_discrete(labels=group_labels_fuzzy) +
  xlab(NULL) +
  ylab("Cover (%)") +
  ggtitle("Perennial herbaceous plants") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"),
        axis.text.y = element_text(color = "black"))

annherb_grps <- c("AH_IntroducedAnnForbCover", "AH_IntroducedAnnGrassCover",
                  "AH_NativeAnnForbCover", "AH_NativeAnnGrassCover")
annherb_cover_states <- ggplot(data = filter(plot_data_first_tall, CoverType %in% annherb_grps),
                               aes(x=PlantCommunity_fuzzy, y=PctCover, fill=CoverType)) +
  geom_boxplot() +
  scale_fill_brewer(type = "qual", palette = "Set3",
                    name = "Functional group",
                    labels = names(cover_labels[which(cover_labels %in% annherb_grps)])) +
  scale_x_discrete(labels=group_labels_fuzzy) +
  xlab(NULL) +
  ylab("Cover (%)") +
  ggtitle("Annual herbaceous plants") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"),
        axis.text.y = element_text(color = "black"))

ground_grps <- c("BareSoilCover", "FH_TotalLitterCover", "CA_percent_200plus",
                 "FH_LichenMossCover", "CA_percent_100plus")
ground_cover_states <- ggplot(data = filter(plot_data_first_tall, CoverType %in% ground_grps),
                              aes(x=PlantCommunity_fuzzy, y=PctCover, fill=CoverType)) +
  geom_boxplot() +
  scale_fill_brewer(type = "qual", palette = "Set3",
                    name = "Functional group",
                    labels = names(cover_labels[which(cover_labels %in% ground_grps)])) +
  scale_x_discrete(labels=group_labels_fuzzy) +
  xlab("Plant community") +
  ylab("Cover (%)") +
  ggtitle("Ground cover") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"),
        axis.text.y = element_text(color = "black"))

cover_states <- cowplot::plot_grid(functypes_cover_states + theme(legend.position = "none"),
                                   woody_cover_states + theme(legend.position = "none"),
                   perenherb_cover_states + theme(legend.position = "none"),
                   annherb_cover_states + theme(legend.position = "none"),
                   ground_cover_states + theme(legend.position = "none"),
                   ncol = 1, axis = "lr", labels = "auto")

cover_axes <- cowplot::plot_grid(cowplot::get_legend(functypes_cover_states),
                                 cowplot::get_legend(woody_cover_states),
                   cowplot::get_legend(perenherb_cover_states),
                   cowplot::get_legend(annherb_cover_states),
                   cowplot::get_legend(ground_cover_states),
                   ncol = 1)

cowplot::plot_grid(cover_states, cover_axes, ncol = 2, rel_widths = c(1, 0.5))
```



```{r groups-climate, echo=FALSE, message=FALSE, warning=FALSE, fig.height=10, fig.width=10, fig.cap="Climate gradients by plant community. Larger aridity index values indicate a LESS arid condition."}
cowplot::plot_grid(
  cowplot::plot_grid(
ggplot(data = plot_data_descriptive,
       aes(x=PlantCommunity_fuzzy, y=AI)) +
  geom_boxplot() +
  scale_x_discrete(labels=group_labels_fuzzy) +
  xlab(NULL) +
  ylab("Aridity index") +
  ylim(c(0, 0.45)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)),
ggplot(data = plot_data_descriptive,
       aes(x=PlantCommunity_fuzzy, y=Ann_ppt_mm)) +
  geom_boxplot() +
  scale_x_discrete(labels=group_labels_fuzzy) +
  xlab(NULL) +
  ylab("Annual precipitation (mm)") +
  ylim(c(0, 650)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)),
nrow = 1, labels = c("a", "b")),
ggplot(data = select(plot_data_descriptive, PlantCommunity_fuzzy, Ann_tmean, Ann_tmax, Ann_tmin) %>%
         tidyr::pivot_longer(c(Ann_tmean, Ann_tmax, Ann_tmin), names_to = "temptype", values_to = "tempdegrees"),
       aes(fill=PlantCommunity_fuzzy, y=tempdegrees, x=temptype)) +
  geom_boxplot() +
  scale_fill_discrete(name="Plant community", labels=group_labels_fuzzy) +
  scale_x_discrete(labels=c("Maximum", "Mean", "Minimum")) +
  xlab(NULL) +
  ylab("Temperature (C)") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)),
nrow = 2, labels = c(NA, "c"))
```



```{r groups-soilstab, echo=FALSE, message=FALSE, warning=FALSE, fig.height=5, fig.width=6.25, fig.cap="Soil stability by plant community"}
ggplot(data = plot_data_descriptive,
       aes(x=PlantCommunity_fuzzy, y=SoilStab_all)) +
  geom_boxplot() +
  scale_x_discrete(labels=group_labels_fuzzy) +
  ylim(c(0, 6)) +
  xlab("Plant community") +
  ylab("Mean soil stability rating") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```



```{r groups-diversity, echo=FALSE, message=FALSE, warning=FALSE, fig.height=5, fig.width=10, fig.cap="(a) Species diversity (Shannon diversity index) and (b) species richness by plant community. Values are based on line-point intercept data, so they may underestimate diversity compared to a full species inventory. Higher diversity values indicate greater diversity (0 indicates a plot that has only one species)."}
cowplot::plot_grid(ggplot(data = plot_data_descriptive,
       aes(x=PlantCommunity_fuzzy, y=shannon_diversity)) +
  geom_boxplot() +
  scale_x_discrete(labels=group_labels_fuzzy) +
  xlab("Plant community") +
  ylab("Shannon diversity index") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)),
  ggplot(data = plot_data_descriptive,
       aes(x=PlantCommunity_fuzzy, y=sp_richness)) +
  geom_boxplot() +
  scale_x_discrete(labels=group_labels_fuzzy) +
  xlab("Plant community") +
  ylab("Number of species") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)),
  nrow = 1, labels = "auto")
```


## State 1
## Shrubland State

TODO write state description

## Community 1.1
## Shrubland State: sagebrush and C3 perennial grass shrubland

TODO write state description

```{r comm1-1-dominant-spp, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
dom_spp_grp3 <- get_dominant_spp(data = filter(plot_data_descriptive, PlantCommunity_fuzzy==3),
                                   species_cols = colnames(descriptive.df),
                                   user = user)

dom_spp_grp3_pub <- filter(
  select(dom_spp_grp3, Indicator, ScientificName, CommonName, SpeciesCode, MeanCover, pct_plots),
               pct_plots >=10) %>%
  mutate(MeanCover = round(MeanCover, 2),
         pct_plots = round(pct_plots, 2)) %>%
  setNames(c("Functional group", "Scientific name", "Common name", "USDA Plants code", "Mean cover (%)", "Percent of plots where present"))


format_tables_EDIT_style(data = dom_spp_grp3_pub,
                         caption = "Community 1.1 plant community composition") %>%
  collapse_rows(columns = 1, valign = "top")
```

```{r echo=FALSE, error=FALSE, warning=FALSE, message=FALSE, fig.cap="Annual production by plant type (representative values) or group (midpoint values)"}
# TODO create pie charts of community composition by functional group. May need to change "production" to "percent cover" to fit with our data
```

```{r echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
# TODO create table of production (or percent cover) by functional type

# knitr::kable(x = dom_plant_spp_tab, caption = "Table 5. Annual production by plant type")
```

```{r echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
# TODO create table of ground cover by type

# knitr::kable(x = dom_plant_spp_tab, caption = "Table 6. Ground cover")
```

```{r echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
# TODO create table of func type percent cover at different heights

# knitr::kable(x = dom_plant_spp_tab, caption = "Table 7. Canopy structure (% cover)")
```

## State 2
## Mesic Shrubland State

## Community 2.1
## Mesic Shrubland State: gambel oak shrubland

TODO write state description

```{r comm2-1-dominant-spp, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
dom_spp_grp4 <- get_dominant_spp(data = filter(plot_data_descriptive, PlantCommunity_fuzzy==4),
                                   species_cols = colnames(descriptive.df),
                                   user = user)

dom_spp_grp4_pub <- filter(
  select(dom_spp_grp4, Indicator, ScientificName, CommonName, SpeciesCode, MeanCover, pct_plots),
               pct_plots >=10) %>%
    mutate(MeanCover = round(MeanCover, 2),
         pct_plots = round(pct_plots, 2)) %>%
  setNames(c("Functional group", "Scientific name", "Common name", "USDA Plants code", "Mean cover (%)", "Percent of plots where present"))


format_tables_EDIT_style(data = dom_spp_grp4_pub,
                         caption = "Community 2.1 plant community composition") %>%
  collapse_rows(columns = 1, valign = "top")
```

## State 3
## Grassland State

TODO write state description

## Community 3.1
## Grassland State: C4 and C3 perennial grassland

TODO write state description

```{r comm3-1-dominant-spp, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
dom_spp_grp1 <- get_dominant_spp(data = filter(plot_data_descriptive, PlantCommunity_fuzzy==1),
                                   species_cols = colnames(descriptive.df),
                                   user = user)

dom_spp_grp1_pub <- filter(
  select(dom_spp_grp1, Indicator, ScientificName, CommonName, SpeciesCode, MeanCover, pct_plots),
               pct_plots >=10) %>%
  mutate(MeanCover = round(MeanCover, 2),
         pct_plots = round(pct_plots, 2)) %>%
  setNames(c("Functional group", "Scientific name", "Common name", "USDA Plants code", "Mean cover (%)", "Percent of plots where present"))


format_tables_EDIT_style(data = dom_spp_grp1_pub,
                         caption = "Community 3.1 plant community composition") %>%
  collapse_rows(columns = 1, valign = "top")
```

## State 4
## Perennial Grass Loss State

TODO write state description

## Community 4.1
## Perennial Grass Loss State: Depauperate grassland

TODO write state description

```{r comm4-1-dominant-spp, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
dom_spp_grp2 <- get_dominant_spp(data = filter(plot_data_descriptive, PlantCommunity_fuzzy==2),
                                   species_cols = colnames(descriptive.df),
                                   user = user)

dom_spp_grp2_pub <- filter(
  select(dom_spp_grp2, Indicator, ScientificName, CommonName, SpeciesCode, MeanCover, pct_plots),
               pct_plots >=10) %>%
  mutate(MeanCover = round(MeanCover, 2),
         pct_plots = round(pct_plots, 2)) %>%
  setNames(c("Functional group", "Scientific name", "Common name", "USDA Plants code", "Mean cover (%)", "Percent of plots where present"))


format_tables_EDIT_style(data = dom_spp_grp2_pub,
                         caption = "Community 4.1 plant community composition") %>%
  collapse_rows(columns = 1, valign = "top")
```

## State 5
## Invaded State

TODO write state description

## Community 5.1
## Invaded State: Non-native annual grassland

TODO write state description

```{r comm5-1-dominant-spp, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
dom_spp_grp5 <- get_dominant_spp(data = filter(plot_data_descriptive, PlantCommunity_fuzzy==5),
                                   species_cols = colnames(descriptive.df),
                                   user = user)

dom_spp_grp5_pub <- filter(
  select(dom_spp_grp5, Indicator, ScientificName, CommonName, SpeciesCode, MeanCover, pct_plots),
               pct_plots >=10) %>%
  mutate(MeanCover = round(MeanCover, 2),
         pct_plots = round(pct_plots, 2)) %>%
  setNames(c("Functional group", "Scientific name", "Common name", "USDA Plants code", "Mean cover (%)", "Percent of plots where present"))


format_tables_EDIT_style(data = dom_spp_grp5_pub,
                         caption = "Community 5.1 plant community composition") %>%
  collapse_rows(columns = 1, valign = "top")
```

### Additional community tables

```{r echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
# TODO create table of production (or percent cover) by species, with species linking to their USDA Plants profile

# knitr::kable(x = dom_plant_spp_tab, caption = "Table 8. Community 1.1 plant community composition")
```

# Interpretations

## Animal community

TODO write wildlife narrative

## Hydrological functions

TODO write hydrology narrative

## Recreational uses

TODO write recreation narrative

## Wood products

TODO write wood production narrative (probably "None")

## Other products

TODO grazing narrative could go here

# Supporting information

## Other references

Herrick, J. E., Van Zee, J. W., McCord, S. E., Courtright, E. M., Karl, J. W., & Burkett, L. M. (2017). Monitoring Manual for Grassland, Shrubland, and Savanna Ecosystems (Second ed. Vol. 1: Core Methods). Las Cruces, New Mexico: USDA-ARS Jornada Experimental Range.

Maechler, M., Rousseeuw, P., Struyf, A., Hubert, M., Hornik, K.(2021).  cluster: Cluster Analysis Basics and Extensions. R package version 2.1.2.

McCord, S.E., N.G. Stauffer. terradactyl: an example of modularity and ontologies to ensure the sustainability of open source software. Society for Range Management  73rd Annual Meeting. February 16-20, 2020. Denver, Colorado.

Nauman, T. W., Burch, S. S., Humphries, J. T., Knight, A. C., & Duniway, M. C. (2022). A Quantitative Soil-Geomorphic Framework for Developing and Mapping Ecological Site Groups. Rangeland Ecology & Management, 81, 9-33. doi:10.1016/j.rama.2021.11.003

Oksanen, J., F. Guillaume Blanchet, Michael Friendly, Roeland Kindt, Pierre Legendre, Dan McGlinn, Peter R. Minchin, R. B. O'Hara, Gavin L. Simpson, Peter Solymos, M. Henry H. Stevens, Eduard Szoecs and Helene Wagner (2020). vegan: Community Ecology Package. R package version 2.5-7. https://CRAN.R-project.org/package=vegan

## Contributors

+ Anna Knight
+ Travis Nauman
+ Samuel Burch
+ Mike Duniway

# Reference sheet

[Interpreting Indicators of Rangeland Health](https://wiki.landscapetoolbox.org/doku.php/field_methods:rangeland_health_assessment_i.e._indicators_of_rangeland_health) is a qualitative assessment protocol used to determine ecosystem condition based on benchmark characteristics described in the Reference Sheet. A suite of 17 (or more) indicators are typically considered in an assessment. The ecological site(s) representative of an assessment location must be known prior to applying the protocol and must be verified based on soils and climate. Current plant community cannot be used to identify the ecological site.

```{r echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}
# TODO create table with author, author contact info, date, approver, approved date, and "Composition (Indicators 10 and 12) based on" info for the IIRH reference sheet

# knitr::kable(x = dom_plant_spp_tab)
```

## Indicators

TODO fill in the 17 IIRH indicators for the reference state if available

TODO link to PDF of the reference sheet

# Print options

TODO look into options for printing from the RMarkdown HTML format


